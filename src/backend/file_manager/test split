use std::env;
use std::error::Error;
use std::fs;
use std::path::Path;

// Import metadata-handling functions.
use s4_vaultify::backend::file_manager::metadata_handing::{detect_type, md_treatment, read_bytes};

// Import binary file utilities from our module (assume binary_utils.rs is in your project).
use s4_vaultify::backend::file_manager::file_handling::{clear_binary, open_file_binary, save_binary};

fn main() -> Result<(), Box<dyn Error>> {
    println!("DEBUG: Starting main function.");

    // Optionally clear the binary_files directory before running the test.
    println!("DEBUG: Clearing binary files directory.");
    clear_binary();

    // Retrieve the file path from the command line or use a default HEIF image path.
    let args: Vec<String> = env::args().collect();
    let file_path = if args.len() > 1 {
        &args[1]
    } else {
        // Default path: replace with a valid path to a HEIF/HEIC image on your system.
        "/Users/lothaire/Document/photos/IMG_1204.HEIC"
    };
    println!("DEBUG: File path: {}", file_path);

    // Read the file bytes using the metadata handling function.
    println!("DEBUG: Reading file bytes with read_bytes.");
    let buffer = read_bytes(file_path)?;
    println!("DEBUG: {} bytes read.", buffer.len());

    // Detect the file type from the buffer.
    println!("DEBUG: Detecting file type.");
    let file_type = detect_type(&buffer);
    println!("DEBUG: Detected file type: {:?}", file_type);

    // Process metadata (if applicable for the image).
    println!("DEBUG: Processing metadata.");
    md_treatment(&buffer, file_type)?;

    // Use the binary file functions to test reading and saving.
    println!("DEBUG: Opening file as binary.");
    let path = Path::new(file_path);
    let binary_data = open_file_binary(path);
    println!("DEBUG: {} bytes read via binary function.", binary_data.len());

    println!("DEBUG: Saving binary file using binary utilities.");
    save_binary(&binary_data);
    println!("DEBUG: Binary file saved in binary_files directory.");

    // If the detected type corresponds to a HEIF/HEIC image, write the file back with a .heif extension.
    // (The actual condition depends on your detect_type implementation.)
    if format!("{:?}", file_type).to_lowercase().contains("heic")
        || format!("{:?}", file_type).to_lowercase().contains("heif")
    {
        let output_path = env::current_dir()?.join("output.heif");
        println!("DEBUG: Detected HEIF image. Writing output to {:?}", output_path);
        fs::write(&output_path, &buffer)?;
    } else {
        println!("DEBUG: File is not a HEIF image; skipping HEIF output generation.");
    }

    // List files in the binary_files directory for confirmation.
    let binary_dir = env::current_dir()?.join("binary_files");
    println!("DEBUG: Listing files in binary_files directory:");
    for entry in fs::read_dir(&binary_dir)? {
        let entry = entry?;
        println!(" - {:?}", entry.path());
    }

    println!("DEBUG: End of main function.");
    Ok(())
}